// contracts/ERC20/GasOptimizedToken.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract GasOptimizedToken {
    // Packed storage for address balances and allowances
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    
    uint256 private _totalSupply;
    string private _name;
    string private _symbol;
    
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }
    
    // Gas-optimized transfer using unchecked for overflow safety
    function transfer(address to, uint256 amount) public virtual returns (bool) {
        address owner = msg.sender;
        _transfer(owner, to, amount);
        return true;
    }
    
    function _transfer(address from, address to, uint256 amount) internal virtual {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");
        
        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
        
        // Use unchecked for gas savings (checked by require above)
        unchecked {
            _balances[from] = fromBalance - amount;
            _balances[to] += amount;
        }
        
        // Emit event
        emit Transfer(from, to, amount);
    }
    
    // Pack approvals and transfers for batch operations
    function batchTransfer(
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external returns (bool) {
        require(recipients.length == amounts.length, "Arrays length mismatch");
        
        uint256 totalAmount;
        for (uint256 i = 0; i < amounts.length; i++) {
            totalAmount += amounts[i];
        }
        
        require(_balances[msg.sender] >= totalAmount, "Insufficient balance");
        
        // Gas optimization: cache balance in memory
        uint256 senderBalance = _balances[msg.sender];
        unchecked {
            _balances[msg.sender] = senderBalance - totalAmount;
            
            for (uint256 i = 0; i < recipients.length; i++) {
                _balances[recipients[i]] += amounts[i];
                emit Transfer(msg.sender, recipients[i], amounts[i]);
            }
        }
        
        return true;
    }
}